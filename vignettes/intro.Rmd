---
title: "Introduction to ZoltR"
author: "Matthew Cornell"
date: "2019-05-02"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to ZoltR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# Welcome
Welcome to the ZoltR introduction vignette. Here we demonstrate the package's main features. Note that before starting
you should:

- create an account on [zoltardata.com](https://www.zoltardata.com/)
- create a 'sandbox' project with one timezero for testing
- create a model in that project
- edit the [`.Renviron`](https://csgillespie.github.io/efficientR/3-3-r-startup.html#renviron) file:
    - `USERNAME` and `PASSWORD`: should match your account settings
    - `PROJECT_NAME` and `MODEL_NAME`: should match your project and model
    - `TIMEZERO_DATE`: should match your project
    - `FORECAST_CSV_FILE`: the path of a forecast data file in the format documented in
      [Zoltar documentation](https://www.zoltardata.com/docs)


## Connect to the host and authenticate

The starting point for working with Zoltar's API is a `ZoltarConnection` object, obtained via the `new_connection` 
function. Here we explicitly pass the HOST address, but you can omit it, which will use the default of
[zoltardata.com](https://www.zoltardata.com/). (Note: Below you will see the host shown as _127.0.0.1:8000_ - this is a
temporary one used to run this documentation against.)

Most functions take a `ZoltarConnection` along with the ID of the thing of interest, e.g., a project, model, or forecast
ID. You can obtain the ID using one of the `*_info` functions.

Currently, all API activity first requires authenticating via the `z_authenticate()` function. Pass it the username and 
password for your account. Note that currently Zoltar uses a five minute timeout on the underlying JWT tokens used under 
the hood, which means you'll have to re-authenticate after that time. Later some kind of auto-re-authenticate might be 
written. <- todo verify

```{r setup}
library(zoltr)
library(httr)  # o/w devtools::check() gets `could not find function "POST"` error
```

<!-- run but don't show -->
```{r, include=FALSE}
conn <- new_connection(host = Sys.getenv("HOST"))
z_authenticate(conn, Sys.getenv("USERNAME"), Sys.getenv("PASSWORD"))
conn
```

<!-- show but don't run-->
```{r, eval=FALSE}
conn <- new_connection()
z_authenticate(conn, Sys.getenv("USERNAME"), Sys.getenv("PASSWORD"))
conn
```


## Get a list of all projects on the host

Use the `projects()` function to get a connection's projects as a data.frame. Note that it will only list those that you
are authenticated to access.

```{r}
the_projects <- projects(conn)
str(the_projects)
```


## Get the sandbox project to work with, and list its info and models

Get the project by named by PROJECT_NAME and then pass its ID to the `project_info()` function to get details, and pass
it to the `models()` function to get a data.frame of its models.

```{r}
project_id <- the_projects[the_projects$name == Sys.getenv("PROJECT_NAME"), 'id']  # integer(0) if not found, which is an invalid project ID
the_project_info <- project_info(conn, project_id)
str(the_project_info)

the_models <- models(conn, project_id)
str(the_models)
```


## Get a sandbox model to work with, and list its info and forecasts (if any)

Get the model ID specified by MODEL_NAME and then pass it to the `model_info()` function to get details, and to the
`forecasts()` function to get a data.frame of its forecasts.

```{r}
model_id <- the_models[the_models$name == Sys.getenv("MODEL_NAME"), 'id']  # integer(0) if not found, which is an invalid model ID
the_model_info <- model_info(conn, project_id)
str(the_model_info)

the_forecasts <- forecasts(conn, model_id)
str(the_forecasts)
```


## Delete the model's existing forecast for TIMEZERO_DATE, if any

Get the forecast for the timezero date specified by TIMEZERO_DATE and then call `delete_forecast()` to delete it, if
one was found.

```{r}
timezero_date_str <- Sys.getenv("TIMEZERO_DATE")
timezero_date <- as.Date(timezero_date_str, format = "%Y%m%d")  # YYYYMMDD
existing_forecast_id <- the_forecasts[the_forecasts$timezero_date == timezero_date, 'id']
the_forecast_info <- forecast_info(conn, existing_forecast_id)  # `Not Found (HTTP 404)` this if forecast doesn't exist 
str(the_forecast_info)
delete_forecast(conn, the_forecast_info$id)
```


## Upload a forecast

Now let's upload the forecast data file FORECAST_CSV_FILE for TIMEZERO_DATE via the `upload_forecast()` function.

Keep in mind that Zoltar queues long operations like forecast uploading, which makes the Zoltar API a little more
complicated. Rather than having the `upload_forecast()` function _block_ until the upload is done, you instead get a
quick response in the form of an `UploadFileJob` ID that you can pass to the `upload_info()` function to check its 
status to find out when the upload is done (or failed). (This is called _polling_ the host to ask the status.) Here we 
poll every second using a helper function.

```{r}
busy_poll_upload_file_job <- function(upload_file_job_id) {
    cat(paste0("polling for status change. upload_file_job: ", upload_file_job_id, "\n"))
    while (TRUE) {
        status <- upload_info(conn, upload_file_job_id)$status
        cat(paste0(status, "\n"))
        if (status == "FAILED") {
            cat(paste0("x failed\n"))
            break
        }
        if (status == "SUCCESS") {
            break
        }
        Sys.sleep(1)
    }
}
```


```{r}
forecast_csv_file <- Sys.getenv("FORECAST_CSV_FILE")
upload_file_job_id <- upload_forecast(conn, model_id, timezero_date_str, forecast_csv_file)
busy_poll_upload_file_job(upload_file_job_id)
```


And here's the upload's final information:

```{r}
the_upload_info <- upload_info(conn, upload_file_job_id)
str(the_upload_info)
```


## Print information about the newly-uploaded forecast

Hopefully you'll see some number of "QUEUED" entries followed by a "SUCCESS" one. Now let's get the new forecast's
information.

Due to there being multiple kinds of files you might upload to Zoltar (including project truth, project template, and
model forecasts), the API returns information about uploaded files in the `$output_json` field of successful upload
job's info. For new forecasts, that field contains a `$forecast_pk` field.

```{r}

new_forecast_id <- upload_info(conn, upload_file_job_id)$output_json$forecast_pk
the_forecast_info <- forecast_info(conn, new_forecast_id)
str(the_forecast_info)
```


## Look at the model's forecast list to see the new forecast

Let's again examine the model's forecasts and notice the new one is there.

```{r}
the_forecasts <- forecasts(conn, model_id)
str(the_forecasts)
```


## Finally, download the new forecast's data in two different formats

You can get forecast data using the `forecast_data()` function, which supports `list` (nested) or `data.table` (tabular)
formats.

First as a `list`. (Please see [here](http://127.0.0.1:8000/docs#forecast-data-format) for JSON format details.) 

```{r}
forecast_data <- forecast_data(conn, new_forecast_id, is_json=TRUE)
forecast_data$locations[[1]]$name
forecast_data$locations[[1]]$targets[[1]]$name
forecast_data$locations[[1]]$targets[[1]]$bins
```

And as a `data.frame`:

```{r}
forecast_data <- suppressMessages(forecast_data(conn, new_forecast_id, is_json=FALSE))
str(forecast_data)
```
